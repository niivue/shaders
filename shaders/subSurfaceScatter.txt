#version 300 es
precision highp int;
precision highp float;

uniform float opacity;

in vec4 vClr;
in vec3 vN;

out vec4 color;

void main() {
	vec3 lightDir = normalize(vec3(0.0, -1.0, 1.0));
	vec3 uLightColor = vec3(01.0, 1.0, 1.0); // light color / intensity
	vec3 uScatterColor = vec3(1.0, 0.85, 0.85); // subsurface tint
	float uWrap = 1.0; // wrap factor [0..1], 0=no-wrap, 1=full wrap
	float uSpecular = 0.1;
	float uShininess = 2.0;
	// ray direction (orthographic / camera along +Z)
	vec3 r = vec3(0.0, 0.0, 1.0);
	float ambientFactor = 0.1;
	// normalize
	vec3 n = normalize(vN);

	// ----- Hemispheric-ish ambient baseline (keeps your feel) -----
	vec3 ambient = vClr.rgb * ambientFactor;

	// ----- Wrapped diffuse (simple SSS illusion) -----
	// wrappedDiffuse = max( (dot(n,l) + wrap) / (1 + wrap), 0 )
	// This "wraps" light around the surface so grazing areas receive light (simulates scattering)
	float NdotL = dot(n, lightDir);
	float wrapped = (NdotL + uWrap) / (1.0 + uWrap);
	wrapped = max(wrapped, 0.0);
	float diffuseFactor = 0.5;
	vec3 diffuse = vClr.rgb * diffuseFactor * wrapped * uLightColor;

	// ----- Backlit / subsurface tint (cheap approximation) -----
	// Use the negative NÂ·L (light coming from behind) to add a colored rim / subsurface glow.
	// Strength controlled by how strongly you want the scattering (0..1)
	float backFacing = clamp(-NdotL, 0.0, 1.0);
	// soften and shape the falloff with a power
	float scatterShape = pow(backFacing, 1.5);
	// subsurface contribution - scaled down a bit to blend naturally
	vec3 subsurface = uScatterColor * 0.6 * scatterShape * uLightColor;

	// ----- Specular (keeps Phong-like feel) -----
	vec3 refl = reflect(-lightDir, n);
	float spec = uSpecular * pow(max(dot(refl, r), 0.0), uShininess);

	// combine
	vec3 outColor = ambient + diffuse + subsurface + vec3(spec);

	// simple tonemap / clamp
	outColor = clamp(outColor, 0.0, 1.0);
	color = vec4(outColor, opacity);
}